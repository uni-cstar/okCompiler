package unics.okcompiler.sample;

import com.google.auto.service.AutoService;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.MirroredTypesException;
import javax.lang.model.type.TypeMirror;

import unics.generator.okcompiler.BaseProcessor;
import unics.generator.okcompiler.DroidMethodUtils;
import unics.generator.okcompiler.DroidParamUtils;
import unics.okcompiler.sample_annotation.LeanbackLayout;


@AutoService(Processor.class)
public class LeanbackLayoutProcessor extends BaseProcessor {

    private static final String TAG = "LeanbackLayoutProcessor";

    private static final String CLASS_JAVA_DOC = "Generated by bas-leanback-layout-compiler. Do not edit it!\n";
    private static final String PACKAGE_NAME = "droid.leanback.layout";
    private static final String CLASS_PREFIX = "";
    private static final String CLASS_SUFFIX = "Leanback";

    @Override
    protected String getTag() {
        return TAG;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        final Set<String> annotationTypes = new LinkedHashSet<>();
        annotationTypes.add(LeanbackLayout.class.getCanonicalName());
        return annotationTypes;
    }

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(LeanbackLayout.class);
        if (elements == null || elements.isEmpty()) {
            printMessage("process interrupt:elements is empty.");
            return true;
        }
        printDividerMessage("LeanbackLayoutProcessor process START");
        Set<String> viewClassSet = new HashSet<>();
        parseParams(elements, viewClassSet);
        try {
            generateClasses(viewClassSet);
        } catch (IllegalAccessException e) {
            printErrorMessage("IllegalAccessException occurred when generating class file.");
            e.printStackTrace();
        } catch (IOException e) {
            printErrorMessage("IOException occurred when generating class file.");
            e.printStackTrace();
        }
        printDividerMessage("LeanbackLayoutProcessor process END");
        return true;
    }

    private void generateClasses(Set<String> viewClassSet) throws IllegalAccessException, IOException {
        printMessage(String.format("准备生成%d个文件", viewClassSet.size()));
        for (String clazz : viewClassSet) {
            int lastDotIndex = clazz.lastIndexOf(".");
            String superPackageName = clazz.substring(0, lastDotIndex);
            String superClassName = clazz.substring(lastDotIndex + 1);
            String className = CLASS_PREFIX + superClassName + CLASS_SUFFIX;

            printMessage(String.format("正在生成 %s ====>  %s", clazz, className));

            TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(className)
                    .addJavadoc(CLASS_JAVA_DOC)
                    .addModifiers(Modifier.PUBLIC)
                    .superclass(ClassName.get(superPackageName, superClassName));
//                    .addSuperinterface(ClassName.get(PACKAGE_NAME, "LeanbackLayoutHelper.Callback"))
//                    .addField(ClassName.get(PACKAGE_NAME, "LeanbackLayoutHelper"), "layoutHelper", Modifier.PRIVATE, Modifier.FINAL);

            generateMethods(typeBuilder, clazz);

            JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, typeBuilder.build()).build();
            javaFile.writeTo(filer);
        }
    }

    private void generateMethods(TypeSpec.Builder typeBuilder, String clazz) {
        DroidMethodUtils.viewConstructorOverloads(typeBuilder, clazz, constructorCode());
        requestChildFocus(typeBuilder, clazz);
        addFocusables(typeBuilder, clazz);
        onRequestFocusInDescendants(typeBuilder, clazz);
        onViewRemoved(typeBuilder, clazz);
    }

    private void onRequestFocusInDescendants(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec onRequestFocusInDescendants = DroidMethodUtils.onRequestFocusInDescendantsSignature()
                .addCode(CodeBlock.builder()
//                        .beginControlFlow("if(layoutHelper.onRequestFocusInDescendants(direction,previouslyFocusedRect))")
//                        .addStatement("return true")
//                        .nextControlFlow("else")
                        .addStatement("return super.onRequestFocusInDescendants(direction,previouslyFocusedRect)")
//                        .endControlFlow()
                        .build())
                .returns(boolean.class)
                .build();
        typeBuilder.addMethod(onRequestFocusInDescendants);
    }

    private void onViewRemoved(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec onViewRemoved = DroidMethodUtils.onViewRemovedSignature()
                .addStatement("super.onViewRemoved(child)")
//                .addStatement("layoutHelper.onViewRemoved(child)")
                .build();
        typeBuilder.addMethod(onViewRemoved);
    }

    private void addFocusables(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec addFocusables = DroidMethodUtils.addFocusablesSignature()
                .addCode(CodeBlock.builder()
//                        .beginControlFlow("if(!layoutHelper.addFocusables(views,direction,focusableMode))")
                        .addStatement("super.addFocusables(views,direction,focusableMode)")
//                        .endControlFlow()
                        .build())
                .build();
        typeBuilder.addMethod(addFocusables);
    }

    private void requestChildFocus(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec requestChildFocus = DroidMethodUtils.requestChildFocusSignature()
                .addStatement("super.requestChildFocus(child, focused)")
//                .addStatement("layoutHelper.requestChildFocus(child, focused)")
                .build();
        typeBuilder.addMethod(requestChildFocus);
    }

    private void layoutHelperCallbackImpl(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec callSuperBringChildToFront = MethodSpec.methodBuilder("callSuperBringChildToFront")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(DroidParamUtils.viewTypeName(true), "child")
                .addStatement("super.bringChildToFront(child)")
                .build();
        typeBuilder.addMethod(callSuperBringChildToFront);

        MethodSpec callSuperGetChildDrawingOrder = MethodSpec.methodBuilder("callSuperGetChildDrawingOrder")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(int.class, "childCount")
                .addParameter(int.class, "drawingPosition")
                .addStatement("return super.getChildDrawingOrder(childCount, drawingPosition)")
                .returns(int.class)
                .build();
        typeBuilder.addMethod(callSuperGetChildDrawingOrder);

        MethodSpec isChildrenDrawingOrderEnabled = DroidMethodUtils.isChildrenDrawingOrderEnabledSignature()
                .addStatement("return super.isChildrenDrawingOrderEnabled()")
                .returns(boolean.class)
                .build();
        typeBuilder.addMethod(isChildrenDrawingOrderEnabled);
    }

    private CodeBlock constructorCode() {
        return CodeBlock.builder()
                .addStatement("super(context, attrs, defStyleAttr)")
                .build();
    }

    private void parseParams(Set<? extends Element> elements, Set<String> viewClassSet) {
        for (Element element : elements) {
            checkAnnotationValid(element, LeanbackLayout.class);
            TypeElement classElement = (TypeElement) element;
            // 获取该注解的值
            LeanbackLayout badgeAnnotation = classElement.getAnnotation(LeanbackLayout.class);
            try {
                badgeAnnotation.value();
            } catch (MirroredTypesException e) {
                List<? extends TypeMirror> typeMirrors = e.getTypeMirrors();
                for (TypeMirror typeMirror : typeMirrors) {
                    DeclaredType classTypeMirror = (DeclaredType) typeMirror;
                    TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();
                    String qualifiedName = classTypeElement.getQualifiedName().toString();
                    viewClassSet.add(qualifiedName);
                }
            }
        }
    }


}